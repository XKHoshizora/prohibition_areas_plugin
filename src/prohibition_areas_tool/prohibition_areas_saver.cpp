// prohibition_areas_saver.cpp
#include <prohibition_areas_plugin/prohibition_areas_tool/prohibition_areas_saver.h>
#include <ros/ros.h>

#include <fstream>

namespace prohibition_areas_tool {

YAML::Node ProhibitionAreasSaver::pointToYaml(
    const geometry_msgs::Point& point) {
    YAML::Node node;
    // 按照代价地图插件要求的格式保存点：[x, y, z]
    node.push_back(point.x);
    node.push_back(point.y);
    node.push_back(point.z);
    return node;
}

geometry_msgs::Point ProhibitionAreasSaver::yamlToPoint(
    const YAML::Node& node) {
    geometry_msgs::Point point;
    if (node.IsSequence() && node.size() >= 2) {
        point.x = node[0].as<double>();
        point.y = node[1].as<double>();
        point.z = node.size() > 2 ? node[2].as<double>() : 0.0;
    }
    return point;
}

bool ProhibitionAreasSaver::saveToFile(
    const std::vector<ProhibitionArea>& areas, const std::string& filename) {
    try {
        YAML::Node root;

        for (const auto& area : areas) {
            // 验证区域数据
            if (area.name.empty()) {
                ROS_ERROR("Area name cannot be empty");
                return false;
            }

            if (area.frame_id.empty()) {
                ROS_ERROR("Frame ID cannot be empty");
                return false;
            }

            if (area.points.size() < 3) {
                ROS_ERROR_STREAM("Area '" << area.name
                    << "' must have at least 3 points");
                return false;
            }

            YAML::Node area_node;
            area_node["name"] = area.name;
            area_node["frame_id"] = area.frame_id;

            for (const auto& point : area.points) {
                area_node["points"].push_back(pointToYaml(point));
            }

            root.push_back(area_node);
        }

        std::ofstream fout(filename);
        if (!fout) {
            ROS_ERROR_STREAM("Failed to open file for writing: " << filename);
            return false;
        }

        fout << "# Prohibition Areas - Generated by RViz plugin\n";
        fout << "# Each area must have: name, frame_id, and at least 3 points\n";
        fout << root;
        return true;

    } catch (const YAML::Exception& e) {
        ROS_ERROR_STREAM("Failed to save prohibition areas: " << e.what());
        return false;
    }
}

bool ProhibitionAreasSaver::loadFromFile(
    std::vector<ProhibitionArea>& areas, const std::string& filename) {
    try {
        areas.clear();
        YAML::Node root = YAML::LoadFile(filename);

        if (!root.IsSequence()) {
            ROS_ERROR("Invalid file format: root must be a sequence");
            return false;
        }

        for (const auto& area_node : root) {
            if (!area_node["name"] || !area_node["frame_id"]
                || !area_node["points"]) {
                ROS_ERROR("Invalid area format: missing required fields");
                continue;
            }

            ProhibitionArea area;
            area.name = area_node["name"].as<std::string>();
            area.frame_id = area_node["frame_id"].as<std::string>();

            const auto& points = area_node["points"];
            if (!points.IsSequence() || points.size() < 3) {
                ROS_WARN_STREAM("Skipping area '" << area.name
                    << "': insufficient points");
                continue;
            }

            for (const auto& point_node : points) {
                if (!point_node.IsSequence() || point_node.size() < 2) {
                    ROS_ERROR_STREAM("Invalid point format in area '"
                        << area.name << "'");
                    continue;
                }
                area.points.push_back(yamlToPoint(point_node));
            }

            if (area.points.size() >= 3) {
                areas.push_back(area);
            }
        }

        return !areas.empty();

    } catch (const YAML::Exception& e) {
        ROS_ERROR_STREAM("Failed to load prohibition areas: " << e.what());
        return false;
    }
}

}  // end namespace prohibition_areas_tool